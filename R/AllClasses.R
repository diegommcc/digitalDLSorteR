#' @importFrom methods setClass setOldClass setClassUnion
#' @importFrom utils packageVersion
#' @import SingleCellExperiment SummarizedExperiment
#' @importClassesFrom splatter ZINBParams
#' @importClassesFrom Matrix dgCMatrix
NULL

setOldClass(Classes = 'package_version')
setOldClass("keras.engine.sequential.Sequential")
setOldClass("keras_training_history")

setClassUnion("MatrixOrNULL", c("matrix", "NULL"))
setClassUnion("ListOrNULL", c("list", "NULL"))
setClassUnion("CharacterOrNULL", c("character", "NULL"))
setClassUnion("SingleCellExperimentOrNULL", c("SingleCellExperiment", "NULL"))
setClassUnion("ZINBParamsOrNULL", c("ZINBParams", "NULL"))
setClassUnion("KerasOrList", c("keras.engine.sequential.Sequential", "list"))

## ProbMatrixCellTypes class ----------------------------------------------------

#' The Class ProbMatrixCellTypes
#'
#' The ProbMatrixCellTypes class is a data storage class that contains
#' information concerning to cell composition matrices used for the simulation
#' of bulk RNAseq samples. The matrix is saved in \code{prob.matrix} slot. The
#' rest of slots contain additional information generated during the process and
#' required in subsequent steps.
#'
#' As described in Torroja and Sanchez-Cabo, 2019, the proportions are built
#' using five different methods in order to avoid biases due to the composition
#' of the simulated bulk samples. In \code{plots} slot, plots representing
#' visually the distribution of these probabilities are stored with the aim of
#' offering a way to monitor the different sets of samples generated. These
#' plots can be shown using \code{\link{showProbPlot}} function. See
#' \code{?\link{showProbPlot}} for more details.
#'
#' @slot prob.matrix Matrix of cell proportions generated for the simulation of
#'   bulk samples. Rows correspond to bulk samples which will be generated
#'   (\eqn{i}), columns are the cell types present in the provided single-cell
#'   data (\eqn{j}) and each entry is the proportion of \eqn{j} cell type in
#'   \eqn{i} sample.
#' @slot cell.names Matrix containing the names of the cells that will make up
#'   each simulated bulk sample.
#' @slot set.list List of cells ordered according to the cell type to which they
#'   belong.
#' @slot set Vector with cell names present in the object.
#' @slot plots List of lists with plots showing the distribution of cell
#'   proportions generated by each method during the process. In each list,
#'   \code{boxplot}, \code{violinplot}, \code{linesplot} or \code{nmix} can be
#'   found. Please, see \code{\link{showProbPlot}} for more details.
#' @slot type.data Character with the type of data contained: training or test.
#'
#' @references Torroja, C. y SÃ¡nchez-Cabo, F. (2019). digitalDLSorter: A Deep
#'   Learning algorithm to quantify immune cell populations based on scRNA-Seq
#'   data. Frontiers in Genetics 10, 978. doi: \url{10.3389/fgene.2019.00978}
#'
#' @export ProbMatrixCellTypes
#'   
ProbMatrixCellTypes <- setClass(
  Class = "ProbMatrixCellTypes",
  slots = c(
    prob.matrix = "MatrixOrNULL",
    cell.names = "MatrixOrNULL",
    set.list = "ListOrNULL",
    set = "CharacterOrNULL",
    plots = "ListOrNULL",
    type.data = "CharacterOrNULL"
  )
)

setMethod(
  f = "initialize", signature = "ProbMatrixCellTypes",
  definition = function(
    .Object,
    prob.matrix = NULL,
    cell.names = NULL,
    set.list = NULL,
    set = NULL,
    plots = NULL,
    type.data = NULL
  ) {
    .Object@prob.matrix <- prob.matrix
    .Object@cell.names <- cell.names
    .Object@set.list <- set.list
    .Object@set <- set
    .Object@plots <- plots
    .Object@type.data <- type.data
    return(.Object)
  }
)


setValidity(Class = "ProbMatrixCellTypes",
            method = function(object) {
              if (all(object@type.data != c("train", "test"))) {
                return(FALSE)
              } else {
                return(TRUE)
              }
            })

setMethod(f = "show",
          signature = "ProbMatrixCellTypes",
          definition = function(object) {
            # cat("An object of class", class(object), "\n")
            if (is.null(object@prob.matrix)) {
              cat("ProbMatrixCellTypes object empty")
            } else {
              cat(paste0("  Cell type matrix for ", object@type.data, "data: "))
              cat(paste(dim(object@prob.matrix), 
                        c("bulk samples and", "cell types"), collapse = " "))
            }
          })


## DigitalDLSorterDNN class ----------------------------------------------------

#' The DigitalDLSorterDNN Class
#'
#' The DigitalDLSorterDNN object stores all the information related to Deep
#' Neural Network model. It contains the trained model, the training history and
#' the results of prediction on test data. After running
#' \code{\link{calculateEvalMetrics}}, it is possible to find the performance
#' evaluation of the model on test data (see \code{?\link{calculateEvalMetrics}}
#' for details).
#'
#' The steps related to Deep Learning are carried out using \pkg{keras} package
#' which uses R6 classes. If you want to save the object as an RDS file,
#' \code{digitalDLSorteR} provides a \code{saveRDS} generic function that
#' transforms the model stored as an R6 object into a native valid R object.
#' Specifically, the model is converted into a list with the architecture of the
#' network and the weights learned during training. That is the minimum
#' information needed to use the model as predictor. If you want to maintain the
#' optimizer state, see \code{?\link{saveTrainedModelAsH5}}. If you want to
#' store \code{\link{DigitalDLSorter}} object as an RDA file, see
#' \code{?\link{preparingToSave}}.
#'
#' @slot model Trained Deep Neural Network. This slot can contain a R6
#'   \code{keras.engine.sequential.Sequential} object or a list with two
#'   elements: the architecture of the model and the resulting weights after
#'   training.
#' @slot training.history List with the evolution of selected metrics during
#'   training.
#' @slot test.metrics Performance of the model on test data.
#' @slot test.pred Deconvolution results on test data. Columns are cell types,
#'   rows are samples and each entry corresponds to the proportion of this cell
#'   type in this sample.
#' @slot cell.types Vector with cell types to deconvolute.
#' @slot features Vector with features used during training. These features will
#'   be used in subsequent predictions (the nomenclature used must be the same).
#' @slot test.deconv.metrics Model performance on each sample of test data
#'   compared to known cell proportions. This slot is used after
#'   \code{?\link{calculateEvalMetrics}}, so see
#'   \code{?\link{calculateEvalMetrics}} for more details.
#'
#' @export DigitalDLSorterDNN
#'   
DigitalDLSorterDNN <- setClass(
  Class = "DigitalDLSorterDNN",
  slots = c(
    model = "KerasOrList",
    training.history = "keras_training_history",
    test.metrics = "ListOrNULL",
    test.pred = "MatrixOrNULL",
    cell.types = "character",
    features = "character",
    test.deconv.metrics = "ListOrNULL"
  )
)

setMethod(
  f = "initialize", signature = "DigitalDLSorterDNN",
  definition = function(
    .Object,
    model = NULL,
    training.history = NULL,
    test.metrics = NULL,
    test.pred = NULL,
    cell.types = NULL,
    features = NULL,
    test.deconv.metrics = NULL
  ) {
    .Object@model <- model
    .Object@training.history <- training.history
    .Object@test.metrics <- test.metrics
    .Object@test.pred <- test.pred
    .Object@cell.types <- cell.types
    .Object@features <- features
    .Object@test.deconv.metrics <- test.deconv.metrics
    return(.Object)
  }
)

setMethod(
  f = "show",
  signature = "DigitalDLSorterDNN",
  definition = function(object) {
    # cat("An object of class", class(object), "\n")
    if (is.null(object@model)) {
      cat("DigitalDLSorterDNN object empty")
    } else {
      cat(paste("Trained model:", object@training.history$params$epochs,
                "epochs\n"))
      train.metrics <- lapply(object@training.history$metrics,
                              function(x) x[length(x)])
      cat("  Training metrics (last epoch):\n")
      cat(paste0("    ", names(train.metrics), ": ",
                 lapply(train.metrics, round, 4),
                 collapse = "\n"))
      cat("\n  Evaluation metrics on test data:\n")
      cat(paste0("    ", names(object@test.metrics), ": ",
                 lapply(object@test.metrics, round, 4),
                 collapse = "\n"))
      if (!is.null(test.deconv.metrics(object)) ||
          length(test.deconv.metrics(object)) > 0) {
        cat("\n  Performance evaluation over each sample: ")
        cat(paste(names(test.deconv.metrics(object)[[2]]), collapse = " "))
      }
    }
  }
)

setClassUnion("DigitalDLSorterDNNOrNULL", c("DigitalDLSorterDNN", "NULL"))


## DigitalDLSorter class -------------------------------------------------------

#' The DigitalDLSorter Class
#'
#' The DigitalDLSorter object is the core of \code{digitalDLSorteR}. This object
#' stores different intermediate data resulting from building new deconvolution
#' models from single-cell data. It is only used in the case of building new
#' deconvolution models. For deconvolving bulk samples using pre-trained models,
#' see \code{\link{deconvDigitalDLSorter}} function.
#'
#' This object uses other classes to store the different types of data produced
#' during the process: \itemize{ \item \code{\linkS4class{SingleCellExperiment}}
#' class for single-cell RNA-seq data, using sparse matrix from the
#' \pkg{Matrix} package (\code{\linkS4class{dgCMatrix}} class) or
#' \code{HDF5Array} class in the case of using HDF5 files as
#' back-end (see below for more information). \item
#' \code{\linkS4class{ZINBParams}} class with estimated parameters for the
#' simulation of new single-cell profiles. \item
#' \code{\linkS4class{SummarizedExperiment}} class for storing bulk RNA-seq
#' data. \item \code{\linkS4class{ProbMatrixCellTypes}} class for the
#' composition cell matrices built during the process. See
#' \code{?\linkS4class{ProbMatrixCellTypes}} for details. \item
#' \code{\linkS4class{DigitalDLSorterDNN}} class to store the information
#' related to Deep Neural Network. This step is performed using \code{keras}.
#' See \code{?\linkS4class{DigitalDLSorterDNN}} for details. }
#'
#' @slot single.cell.real Real single-cell data stored in a
#'   \code{SingleCellExperiment} object. The count matrix is stored as
#'   \code{\linkS4class{dgCMatrix}} or \code{HDF5Array} objects.
#' @slot zinb.params \code{\linkS4class{ZINBParams}} object with estimated
#'   parameters for the simulation of new single-cell expression profiles.
#' @slot single.cell.simul Simulated single-cell expression profiles from
#'   ZINB-WaVE model.
#' @slot prob.cell.types \code{\linkS4class{ProbMatrixCellTypes}} class with
#'   cell composition matrices built for the simulation of bulk RNA-seq profiles
#'   with known cell composition.
#' @slot bulk.simul A list with train and test simulated bulk RNA-seq samples.
#'   Each entry is a \code{\linkS4class{SummarizedExperiment}} object. The
#'   count matrices can be stored as \code{HDF5Array} files using
#'   HDF5 files as back-end in case of RAM memory limitations.
#' @slot trained.model \code{\linkS4class{DigitalDLSorterDNN}} object with all
#'   the information related to the trained model. See
#'   \code{?\linkS4class{DigitalDLSorterDNN}} for more details.
#' @slot deconv.data List of \code{\linkS4class{SummarizedExperiment}} objects
#'   where it is possible to store new bulk RNA-seq experiments for their
#'   deconvolution. The name of the entries corresponds to the name of provided
#'   data. See \code{\link{deconvDigitalDLSorterObj}} for details.
#' @slot deconv.results Slot containing the deconvolution results from applying
#'   the deconvolution model to data present in \code{\link{deconv.data}} slot.
#'   It is a list in which the names corresponds to the data from which they
#'   come.
#' @slot project Name of the project.
#' @slot version Version of DigitalDLSorteR this object was built under.
#'
#'   The package can be used in two ways: to build new deconvolution models from
#'   single-cell RNA-seq data or to deconvolute bulk RNA-seq samples using
#'   pre-trained models integrated into the package. If you want to build new
#'   models, see \code{\link{loadSCProfiles}} function. If you want to use
#'   pre-trained models, see \code{\link{deconvDigitalDLSorter}} function.
#'
#'   In order to provide a way of working with big amounts of data in machines
#'   with RAM limitations, we provide the possibility of using HDF5 files as
#'   back-end to store count matrices of both single-cell real/simulated and
#'   bulk RNAseq profiles. To do this, we use \code{HDF5Array} and
#'   \code{DelayedArray} classes from the homonymous packages.
#'
#'   Once the neural network is trained, it is possible to save it as RDS, RDA
#'   and HDF5 files. Please, see \code{\linkS4class{DigitalDLSorterDNN}} for
#'   more details.
#'
#' @exportClass DigitalDLSorter
#' @export DigitalDLSorter
#'   
DigitalDLSorter <- setClass(
  Class = "DigitalDLSorter",
  slots = c(
    single.cell.real = "SingleCellExperimentOrNULL",
    zinb.params = "ZINBParamsOrNULL",
    single.cell.simul = "SingleCellExperimentOrNULL",
    prob.cell.types = "ListOrNULL",
    bulk.simul = "ListOrNULL",
    trained.model = "DigitalDLSorterDNNOrNULL",
    deconv.data = "ListOrNULL",
    deconv.results = "ListOrNULL",
    project = "character",
    version = "package_version"
  )
)


setMethod(
  f = "initialize", signature = "DigitalDLSorter",
  definition = function(
    .Object,
    single.cell.real = NULL,
    zinb.params = NULL,
    single.cell.simul = NULL,
    prob.cell.types = NULL,
    bulk.simul = NULL,
    trained.model = NULL,
    deconv.data = NULL,
    deconv.results = NULL,
    project = "DigitalDLSorterProject",
    version = packageVersion(pkg = "digitalDLSorteR")
  ) {
    .Object@single.cell.real <- single.cell.real
    .Object@zinb.params <- zinb.params
    .Object@single.cell.simul <- single.cell.simul
    .Object@prob.cell.types <- prob.cell.types
    .Object@bulk.simul <- bulk.simul
    .Object@trained.model <- trained.model
    .Object@deconv.data <- deconv.data
    .Object@deconv.results <- deconv.results
    .Object@project <- project
    .Object@version <- version
    return(.Object)
  }
)

.sceShow <- function(sce) {
  cat(" ", dim(sce)[1], "features and", dim(sce)[2], "cells\n")
  if (is.null(rownames(sce))) rownames.sce <- "---"
  else rownames.sce <- S4Vectors:::selectSome(rownames(sce), 6)
  if (identical(colnames(sce), character(0))) colnames.sce <- "---"
  else colnames.sce <- S4Vectors:::selectSome(colnames(sce), 6)
  cat("  rownames:", rownames.sce, "\n")
  cat("  colnames:", colnames.sce, "\n")
}

.bulkShow <- function(se) {
  cat("   ", dim(se)[1], "features and", dim(se)[2], "samples\n")
  if (is.null(rowData(se)[[1]])) rownames.se <- "---"
  else rownames.se <- S4Vectors:::selectSome(rownames(rowData(se)), 6)
  if (identical(colnames(se), character(0))) colnames.se <- "---"
  else colnames.se <- S4Vectors:::selectSome(rownames(colData(se)), 6)
  cat("    rownames:", rownames.se, "\n")
  cat("    colnames:", colnames.se, "\n")
}

.finalShow <- function(se) {
  cat("   ", dim(se)[2], "features and", dim(se)[1], "samples: ")
  n.bulk <- sum(grepl("Bulk\\.*", rowData(se)[[1]]))
  n.sc <- abs(n.bulk - dim(se)[1])
  cat(n.bulk, "bulk profiles and", n.sc, "single-cell profiles\n")
  # if (is.null(rowData(se)[[1]])) rownames.se <- "---"
  # else rownames.se <- S4Vectors:::selectSome(rowData(se)[[1]], 6)
  # if (identical(colnames(se), character(0))) colnames.se <- "---"
  # else colnames.se <- S4Vectors:::selectSome(colData(se)[[1]], 6)
  # cat("    rownames:", rownames.se, "\n")
  # cat("    colnames:", colnames.se, "\n")
}

.zinbModelShow <- function(zinb.model) {
  cat(paste0("ZinbParams object:\n",
             "  ", zinbwave::nSamples(zinb.model), " samples; ",
             "  ", zinbwave::nFeatures(zinb.model), " genes.\n",
             "  ", NCOL(zinbwave::getX_mu(zinb.model)),
             " sample-level covariate(s) (mu); ",
             "  ", NCOL(zinbwave::getX_pi(zinb.model)),
             " sample-level covariate(s) (pi);\n",
             "  ", NCOL(zinbwave::getV_mu(zinb.model)),
             " gene-level covariate(s) (mu); ",
             "  ", NCOL(zinbwave::getV_pi(zinb.model)),
             " gene-level covariate(s) (pi);\n",
             "  ", zinbwave::nFactors(zinb.model), " latent factor(s).\n"))
}

.allSlotsNull <- function(object) {
  list.slots <- list(
    "single.cell.real", "zinb.params", "single.cell.simul", "prob.cell.types",
    "bulk.simul", "trained.model", "deconv.data", "deconv.results"
  )
  res <- all(unlist(lapply(list.slots, function(x) is.null(do.call("@", list(object, x))))))
  if (res) return(TRUE)
  else return(FALSE)
}

setMethod(
  f = "show",
  signature = "DigitalDLSorter",
  definition = function(object) {
    if (.allSlotsNull(object)) {
      cat("An empty object of class", class(object), "\n")
      opt <- options(show.error.messages = FALSE)
      on.exit(options(opt))
      stop()
    } else {
      cat("An object of class", class(object), "\n")
    }
    if (!is.null(object@single.cell.real)) {
      cat("Real single-cell profiles:\n")
      .sceShow(object@single.cell.real)
    } else {
      cat("Real single-cell profiles:\n")
      .sceShow(S4Vectors::DataFrame())
    }
    if (!is.null(object@zinb.params)) {
      .zinbModelShow(object@zinb.params@model)
    }
    if (!is.null(object@single.cell.simul)) {
      cat("Simulated single-cell profiles:\n")
      .sceShow(object@single.cell.simul)
    }
    if (!is.null(object@prob.cell.types)) {
      cat("Cell type composition matrices:\n")
      lapply(X = c("train", "test"), FUN = function(x) {
        if (x %in% names(object@prob.cell.types)) {
          cat(show(object@prob.cell.types[[x]]), "\n")
        }
      })
    }
    if (!is.null(object@bulk.simul)) {
      cat("Simulated bulk samples:\n")
      lapply(
        X = c("train", "test"), FUN = function(x) {
          if (x %in% names(object@bulk.simul)) {
            cat(paste(" ", x, "bulk samples:\n"))
            .bulkShow(object@bulk.simul[[x]])
          }
        }
      )
    }
    if (!is.null(object@trained.model)) {
      cat(show(object@trained.model), "\n")
    }
    if (!is.null(object@deconv.data)) {
      cat("Bulk samples to deconvolute:\n")
      lapply(
        X = names(object@deconv.data), FUN = function(x) {
          if (x %in% names(object@deconv.data)) {
            cat(paste(" ", x, "bulk samples:\n"))
            .bulkShow(object@deconv.data[[x]])
          }
        }
      )
    }
    if (!is.null(object@deconv.results)) {
      cat("Results (estimated cell proportions):\n")
      lapply(
        X = names(object@deconv.results), FUN = function(x) {
          if (x %in% names(object@deconv.results)) {
            cat(paste("  Results of", x, "bulk samples\n"))
          }
        }
      )
    }
    cat("Project:", object@project, "\n")
  }
)
